{"version":3,"sources":["cancellationToken.ts"],"names":[],"mappings":";AAEA,uBAA0B;AAQ1B,oBAAoB,IAAY;IAC5B,IAAI;QACA,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAClB,OAAO,IAAI,CAAC;KACf;IACD,OAAO,CAAC,EAAE;QACN,OAAO,KAAK,CAAC;KAChB;AACL,CAAC;AAED,iCAAiC,IAAc;IAC3C,IAAI,oBAA4B,CAAC;IACjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;QACtC,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,wBAAwB,EAAE;YACtC,oBAAoB,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACnC,MAAM;SACT;KACJ;IACD,IAAI,CAAC,oBAAoB,EAAE;QACvB,OAAO;YACH,uBAAuB,EAAE,cAAM,OAAA,KAAK,EAAL,CAAK;YACpC,UAAU,EAAE,UAAC,UAAkB,IAAW,OAAA,KAAK,CAAC,EAAN,CAAM;YAChD,YAAY,EAAE,UAAC,UAAkB,IAAW,OAAA,KAAK,CAAC,EAAN,CAAM;SACrD,CAAC;KACL;IAMD,IAAI,oBAAoB,CAAC,MAAM,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;QACtE,IAAM,YAAU,GAAG,oBAAoB,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACrD,IAAI,YAAU,CAAC,MAAM,KAAK,CAAC,IAAI,YAAU,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACzD,MAAM,IAAI,KAAK,CAAC,wHAAwH,CAAC,CAAC;SAC7I;QACD,IAAI,oBAA0B,CAAC;QAC/B,IAAI,kBAAwB,CAAC;QAC7B,OAAO;YACH,uBAAuB,EAAE,cAAM,OAAA,oBAAkB,KAAK,SAAS,IAAI,UAAU,CAAC,oBAAkB,CAAC,EAAlE,CAAkE;YACjG,UAAU,YAAC,SAAiB;gBACxB,kBAAgB,GAAG,SAAS,CAAC;gBAC7B,oBAAkB,GAAG,YAAU,GAAG,SAAS,CAAC;YAChD,CAAC;YACD,YAAY,YAAC,SAAiB;gBAC1B,IAAI,kBAAgB,KAAK,SAAS,EAAE;oBAChC,MAAM,IAAI,KAAK,CAAC,qCAAmC,kBAAgB,iBAAY,SAAW,CAAC,CAAC;iBAC/F;gBACD,oBAAkB,GAAG,SAAS,CAAC;YACnC,CAAC;SACJ,CAAC;KACL;SACI;QACD,OAAO;YACH,uBAAuB,EAAE,cAAM,OAAA,UAAU,CAAC,oBAAoB,CAAC,EAAhC,CAAgC;YAC/D,UAAU,EAAE,UAAC,UAAkB,IAAW,OAAA,KAAK,CAAC,EAAN,CAAM;YAChD,YAAY,EAAE,UAAC,UAAkB,IAAW,OAAA,KAAK,CAAC,EAAN,CAAM;SACrD,CAAC;KACL;AACL,CAAC;AACD,iBAAS,uBAAuB,CAAC","file":"cancellationToken.js","sourcesContent":["/// <reference types=\"node\"/>\r\n\r\nimport fs = require(\"fs\");\r\n\r\ninterface ServerCancellationToken {\r\n    isCancellationRequested(): boolean;\r\n    setRequest(requestId: number): void;\r\n    resetRequest(requestId: number): void;\r\n}\r\n\r\nfunction pipeExists(name: string): boolean {\r\n    try {\r\n        fs.statSync(name);\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction createCancellationToken(args: string[]): ServerCancellationToken {\r\n    let cancellationPipeName: string;\r\n    for (let i = 0; i < args.length - 1; i++) {\r\n        if (args[i] === \"--cancellationPipeName\") {\r\n            cancellationPipeName = args[i + 1];\r\n            break;\r\n        }\r\n    }\r\n    if (!cancellationPipeName) {\r\n        return {\r\n            isCancellationRequested: () => false,\r\n            setRequest: (_requestId: number): void => void 0,\r\n            resetRequest: (_requestId: number): void => void 0\r\n        };\r\n    }\r\n    // cancellationPipeName is a string without '*' inside that can optionally end with '*'\r\n    // when client wants to signal cancellation it should create a named pipe with name=<cancellationPipeName>\r\n    // server will synchronously check the presence of the pipe and treat its existance as indicator that current request should be canceled.\r\n    // in case if client prefers to use more fine-grained schema than one name for all request it can add '*' to the end of cancelellationPipeName.\r\n    // in this case pipe name will be build dynamically as <cancellationPipeName><request_seq>.\r\n    if (cancellationPipeName.charAt(cancellationPipeName.length - 1) === \"*\") {\r\n        const namePrefix = cancellationPipeName.slice(0, -1);\r\n        if (namePrefix.length === 0 || namePrefix.indexOf(\"*\") >= 0) {\r\n            throw new Error(\"Invalid name for template cancellation pipe: it should have length greater than 2 characters and contain only one '*'.\");\r\n        }\r\n        let perRequestPipeName: string;\r\n        let currentRequestId: number;\r\n        return {\r\n            isCancellationRequested: () => perRequestPipeName !== undefined && pipeExists(perRequestPipeName),\r\n            setRequest(requestId: number) {\r\n                currentRequestId = requestId;\r\n                perRequestPipeName = namePrefix + requestId;\r\n            },\r\n            resetRequest(requestId: number) {\r\n                if (currentRequestId !== requestId) {\r\n                    throw new Error(`Mismatched request id, expected ${currentRequestId}, actual ${requestId}`);\r\n                }\r\n                perRequestPipeName = undefined;\r\n            }\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            isCancellationRequested: () => pipeExists(cancellationPipeName),\r\n            setRequest: (_requestId: number): void => void 0,\r\n            resetRequest: (_requestId: number): void => void 0\r\n        };\r\n    }\r\n}\r\nexport = createCancellationToken;\r\n"]}